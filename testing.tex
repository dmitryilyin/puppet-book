\chapter{Тестирование модулей и манифестов}

Ошибки в манифестах Puppet часто могут привести как к их неработоспособности, так и к нарушению работы управляемых систем и потере данных. Поэтому перед запуском новых версий их необходимо сначала проверять. Рассмотрим как можно организовать тестирование.

\section{Методы тестирования}

Методика тестирования может сильно отличаться в зависимости от того, в каких условиях и с какими целями проводятся тесты. Рассмотрим, какими средствами можно выполнять проверку модулей и манфестов.

\subsection{Полный функциональный тест}

Хотя проведение тестов на работающей системе обычно может привести к нарушению её работы и не рекомендуется, иногда может не быть возможности использовать другие методы. В этом случаем можно проводить тестирование на одном из рабочих серверов, или, лучше, на специальной тестовой системе.

Для того, чтобы разработка и отладка новых манифестов не влияла на работу остальных серверов, можно использовать механизм окружений на управляющей системе. Кроме основного набора модулей и манифестов, которые используются всеми серверами, создается еще один дополнительный тестовый набор, который может использоваться только тестовой системой. Изменения в тестовом наборе никак не влияют на работу остальных серверов, но позволяют легко проводить отладку, использую для этого единую инфраструктуру.

Чтобы создать тестовое окружение добавляем в конфигурационный файл \textbf{puppet.conf} на управляющем сервере следующие строчки:

\begin{verbatim}
[testing]
  modulepath = $confdir/environments/testing/modules
  manifest = $confdir/environments/testing/manifests/site.pp
\end{verbatim}

Мы указали, что для окружения \texttt{testing} модули и манфесты будут находиться в отдельном каталоге \texttt{environments/testing}, котоый находтся рядом с основным набором модулей.

На тестовой системе теперь можно запустить агент с дополнительным параметром \texttt{--environment testing}, чтобы он получил каталог, собранный из тестовой ветки.

Кроме \texttt{testing} моджно создать много дополнительных окружений, например разделив резработку и тестирование, или эту же технологию можно использовать для разделения между серверами разных подразделений компании. Окружение по умолчанию называется \texttt{production}, и оно используется, если не создано никаких дополнительных окружений.

В процессе разработки изменения вносятся в тестовую ветку и на одной из систем, которая используется как тестовая, можно проверить их результат. Самый простой способ --- сначала запустить Puppet в режиме \textbf{noop}, с котором никакие изменения не будут на самом деле произведены, а только будет показано, что агент бы сделал. Запустить агент в таком режиме можно так:

\begin{verbatim}
puppet agent --environment=testing --test --noop
\end{verbatim}

Будет выведен список всех изменений, которые были бы сделаны, если бы агент был запущен без ключа \texttt{-{}-noop}. На этом этапе уже можно заметить ошибку, если в списке есть не те изменения, которые хотел выполнить разработчик. Этот метод обычно позволяет обнаружить только логические и смысловые ошибки. Пока нельзя сказать будут ли правильно выполнены все эти изменения и в правильном ли порядке.

Если список изменений выглядит правильным, можно убрать параметр \texttt{-{}-noop} и применить все изменения. При запуске только с параметром \texttt{-{}-test} будут выводиться все выполняемые изменения и ошибки, если они происходят. Такая проверка иногда называется \textit{Smoke Test}, потому что она позволяет быстро проверить не сломали ли систему последние изменения в модуле или манифесте.

\begin{verbatim}
puppet agent --environment=testing --test
\end{verbatim}

Если тест новой версии прошёл успешно на всех тестовых системах, или после исправления всех ошибок и проблем, то можно выложить новую версию из тестового окружения в основное, чтобы оно было применено на всех серверах. Если изменения всё же потенциально могут привести к проблемам, то часто используют поэтапный переход, когда сначала изменения применяются на одной группе серверов, потом, если не возникло проблем, на следующей, и так пока все сервера не будут обновлены.

Использование системы контроля версий позволяет легко вносить изменения, например, сначала в ветку для разработчиков, потом передавать их на тестирование в тестовую ветку, затем, если тесты прошли успешно, передать изменения в основную ветку. Кроме этого можно легко отменить последние изменения и вернуться к более ранней версии, которая работает правильно, если появились непредвиденные проблемы.

Такая методика тестирования уместна, когда Puppet используется для поддержки большой инфраструктуры реальных серверов, которая слишком сложна, чтобы можно было сделать небольшую тестовую модель, которая вела бы себя достаточно похоже на реальную систему.

Тестирование на реальной системе позволяет определить работоспособность манифестов именно в тех условиях, в которых они будут использоваться, или для нескольких ситуаций, которые присутствуют в поддерживаемой системе. Если модуль более универсальный, то можно легко не обнаружить ошибки, которые проявляются в других ситуациях или при редком сочетании параметров.

\subsection{Модульные тесты}

При разработке отдельного модуля часта приходится проверять его работы в разных окружениях с разными входными данными. Использование реальной инфраструктуры обычно позволяет проверить работу только в некоторых ситуациях.

Если не требуется проверка всего набора модулей и манифестов сразу, то можно использовать модульные тесты, которые позволяют проверить работоспособность каждого модуля отдельно, используя при этом специальные тестовые окружения, позволяющие быстро смоделировать разные состояния системы.

Для использование таких тестов сначала нужно подгогтовить примеры использования модуля в разных режимах. Для этого в корне модуля создадим каталог \textbf{tests}. В него можно положить несколько файлов-манифестов, которые включают тестируемый модуль.

Предположим, что у нас есть несложный модуль для установки, запуска или отключения ssh сервера на опреационных системах семейства Debian и RedHat, состоящий из одного параметрического класса.

\lstinputlisting[title={Модуль для установки SSH сервера}]{code/tests/ssh/manifests/init.pp}

Чтобы протестированть работу этого модуля нужно запустить его на разных опреационных системах как в режиме включения, так и выключения сервиса. Создадим в корне модуля папку \textbf{tests}, а в ней создадим два файла, использующих модуль ssh в режиме включения и выключения.

\dirtree{%
.1 ssh.
.2 manifests.
.3 init.pp.
.2 tests.
.3 ssh\_on.pp.
.3 ssh\_off.pp.
}

\lstinputlisting[title={Тест включения SSH}]{code/tests/ssh/tests/ssh_on.pp}
\lstinputlisting[title={Тест выключения SSH}]{code/tests/ssh/tests/ssh_off.pp}

Оба этих файла практически являются примерами использования этого модуля в манифестах, который также можно использовать и для тестирования модуля. Теперь попробуем запустить этот тест. Проще всего для этого использовать Puppet агент в локальном режиме.

\begin{verbatim}
puppet apply --test --modulepath . tests/ssh_off.pp
puppet apply --test --modulepath . tests/ssh_on.pp
\end{verbatim}

Выполнение первого теста должно установить пакет ssh сервера, но оставить сервис выключенным, а второй тест должен ее включить. Можно сначала запустить агент в режиме \textbf{noop}, чтобы не выполнять изменений, а только увидеть их список.

\subsection{Использование Vagrant для модульных тестов}

TODO

\section{Unit тесты Rspec}

\subsection{Разработка через тестирование}

Rspec --- фреймворк для тестирования поведения классов Ruby. Тестирование поведения это практика программирования, при которой перед написанием самой программы создаётся набор тестов, описывающих её поведение в разных режимах и примерах использования. Эти тесты получаются болше похожими на спецификацию или даже документацию, описывающую работу программы.

После написания тестовс они, естественно, не проходят, потому что программы еще не существует и можно переходить к этапу написания самой программы так, чтобы все тесты слали успешными. Обычно процесс разработки построен итеративно. Сначала реализуются тесты для самых базовых возможностей программы, реализуются эти возможности, потом пишутся тесты для дополнительных более продвинутых возможностей и приступают к их реализации. Таким образом на каждой итерации получается работающий продукт, проходящий все тесты и готовый к использованию, но, возможно, имеющий еще не все возможности, которые планировалось. При каждой последующие итерации всегда выполняются все тесты и происходит обнаружение всех возможных регрессий.

Такой процесс разработки лежит в основе методики Agile и сильно отличается от классической модели, при которой сначала планируются все возможности, разрабатывается архитектура, реализуются все компоненты и потом тестируются, что делает довольно сложным внесение изменений в структуру проекта, и работающая версия получается только на последних этапах работы.

Тестирование поведения --- расширение концепции разработки через тестирование, при котором делается фокус не не структуру программы и соответствие работы каждого её компонента спецификации, а на поведение всей программы целиком и ее реакции на различные ситуации и исходные данные.

\subsection{Начало работы с Rspec}

Для начала установим Rspec. Это можно сделать при помощи gem.

\begin{verbatim}
gem install rspec
\end{verbatim}

Или при помощи пакетного менеджера вашего дистрибутива.

\begin{verbatim}
apt-get install ruby-rspec
yum install rubygem-rspec
\end{verbatim}

Для примера разработаем простую программу для сложения чисел. Программа должна складывать все переданные числа и выводить результат.

Описание поведения пишется при помощи специального предметно-ориентированного языка, реализованного на Ruby. При описании используется три ключевых слова: Дано, Если, Тогда. Первое слово --- задание условий, при которых производится тестирование, второе --- некоторое событие или входные данные программы, а третье --- результат, который должна вернуть программа при правильной работе.

Сначала опишем группу тестов при помощи слова \textbf{describe}. Весь связанный с ней блок будет входить в эту группу. Группы могут быть вложенными друг в друга и вместо слова \textbf{describe} может быть использовано слово \textbf{context}, чтобы подчеркнуть разделение тестов на относящиеся к разным условиям. Тесты описываются при помощи ключевого слова \textbf{it}. Описание тестов и контекстов обычно пишут простыми словами, которые были бы понятны не только программистам, но и людям не технических специальностей, но знакомыми с бизнес процессами, делая возможным их участие в составлении описаний программ.

\lstinputlisting[title={Spec для SumNumbers}]{code/rspec/SumNumbers/correct/SumNumbers_spec.rb}

Теперь напишем саму программу так, чтобы все тесты могли завершиться успешно. Создадимк Ruby класс с тремя методами: конструктором, устанавливающим начальное значение, методом, прибавляющем к этому значению число, и методом, возвращающим хранимое значение.

\lstinputlisting[title={Программа SumNumbers}]{code/rspec/SumNumbers/correct/SumNumbers.rb}

Теперь запустим тесты и посмотрим на результат. Тест можно запустить при помощи команды \textbf{rspec}. Укажим формат documentation, чтобы включить вывод всех выполненных тестов.

\begin{verbatim}
rspec -f doc SumNumbers_spec.rb
\end{verbatim}

\verbatiminput{code/rspec/SumNumbers/correct/result.log}

Теперь рассмотрим ситуацию, когда в программе есть ошибка, и тесты завершаются неудачно. Предположим, что был неправильно реализован метод-конструктор и он всегда устанавливает нулевое начальное значение суммы.

\lstinputlisting[title={Программа SumNumbers с ошибкой}]{code/rspec/SumNumbers/error/SumNumbers.rb}

Теперь снова запустим тесты и убедимся в том, что они не проходят.

\verbatiminput{code/rspec/SumNumbers/error/result.log}

\subsection{Совпадения и ожидания}

При проверке соответствия результатов выполнения программы правильному значению используются такие понятия как Expectations (Ожидания) и Matchers (Совпадения). Expectations устанавливаются автоматически при установке rspec и добавляют два метода каждому Ruby объекту, которые используются для сравнения полученного значения с тем, которое должно быть, или не должно быть.

\begin{verbatim}
foo.should eq(bar)
foo.should_not eq(bar)
\end{verbatim}

Можно использовать альтернативный синтаксис:

\begin{verbatim}
expect(foo).to eq(bar)
expect(foo).not_to eq(bar) 
\end{verbatim}

Аргументом для этих объектов должно быть Совпадение. Эти объекты определяют разные условия, которые могут ожидаться или не ожидаться при проверке. Среди встроенных совпадений можно найти равенство, неравенство, нахождение в массиве, принадлежность классу и многие другие.

\begin{description}
\item[Сайт Rspec] \url{http://rspec.info}
\item[Документация] \url{https://www.relishapp.com/rspec}
\item[GitHub] \url{https://github.com/rspec/rspec}
\end{description}

\section{Использование Rspec для проверки модулей Puppet}

\subsection{Подготовка к использованию тестов}

Тестирование поведения модулей и манифестов puppet не предусматривает их запуск на реальной или виртуальной системе, а описывает, какие ресурсы и с какими параметрами должны быть собраны в каталог, который затем был бы исполнен на управляемой системе. Таким образом проверяется логика, реализуемая модулем и манифестом посредством проверки соответствия результатов их работы эталонным результатам в указанных условиях с определёнными параметрами.

Например можно убедиться, что на Debian системе будет установлен пакет apache и создан файл \texttt{mysite.ru.conf} c описанием этого сайта в каталоге \texttt{sites-aviable}  и создана символическая ссылка на этот файл в \texttt{sites-enabled}. А при запуске на Red Hat системе вместо этого будет установлен пакет httpd и создан файл \texttt{mysite.ru.conf} в каталоге \texttt{conf.d}.

Такой тест совершенно не гарантирует, что все эти действия действительно будут выполнены правильно, он только проверяет правильность постановки задачи для исполнения на управляемой системе. Процесс может завершиться неудачно по множеству причин, которые не зависят от правильности написания этого манифеста.

Хотя использование методов разработки через тестирование может показаться бесполезным для не очень сложных модулей и манифестов, при увеличении количества управляемых ресурсов, появлении сложных условий и логики, поддержке многих конфигураций и версий операционных систем и, особенно, при дальнейшей доработке существующих манифестов отладка и тестирование станет очень сложным. Поэтому Unit тесты, хотя и не заменяют проверки на тестовых системах, позволят определить большинство логических ошибок, регрессий и несоответствий спецификации еще до начала тестирования. Кроме этого хорошо написаные тесты также выполняют функцию "исполняемой документации", описывая поведение каждого манифеста на языке, который легко понятен не только компьютеру, но и человеку.

Чтобы использовать Rspec для тестирования модулей Puppet нужно сначала установать пакет rspec-puppet, который можно найти здесь \url{http://rspec-puppet.com}. Кроме него потребуется установить сам puppet и дополнительный пакет puppetlabs\_spec\_helper.

\begin{verbatim}
gem install rspec-puppet
gem install puppetlabs_spec_helper
gem install puppet
\end{verbatim}

\subsection{Тестирование простого класса}

Теперь создадим простой модуль puppet и тесты для него. Предположим, что у нас есть модуль для управления файлом \textbf{/etc/issue}, состоящий из одного класса.

\begin{lstlisting}
class motd {
  file { '/etc/motd' :
    ensure  => present,
    owner   => 'root',
    group   => 'root',
    mode    => '0644',
    content => 'Hello!',
  }
}
\end{lstlisting}

Оформим этот класс как модуль, создав соответствующую структуру каталогов и положив этот класс в файл \textbf{init.pp} в каталоге manifests.

\dirtree{%
.1 modules.
.2 motd.
.3 manifests.
.4 init.pp.
.3 tests.
.3 lib.
.3 files.
.3 templates.
}

Теперь воспользуемся скриптом \textbf{rspec-puppet-init} перейдя в каталог этого модуля чтобы создать необходимую для работы Unit тестов структуру файлов и каталогов.

\begin{verbatim}
 + spec/
 + spec/classes/
 + spec/defines/
 + spec/functions/
 + spec/hosts/
 + spec/fixtures/
 + spec/fixtures/manifests/
 + spec/fixtures/modules/
 + spec/fixtures/modules/motd/
 + spec/fixtures/manifests/site.pp
 + spec/fixtures/modules/motd/manifests
 + spec/spec_helper.rb
 + Rakefile
\end{verbatim}

\begin{description}
\item[classes] В этом каталоге нужно размещать файлы, описывающие поведение классов и параметрических классов.
\item[defines] В этом каталоге нужно размещать описание поведения определений.
\item[hosts] Здесь размещаются описания работы модуля на разных системах.
\item[functions] Описания работы специальных функций, если модуль их содержит.
\item[fixtures] Здесь создаются символические ссылки, имитирующие структуру каталога с модулями puppet чтобы создать подходящие для работы модуля окружение. Файл spec\_helper.rb используется для выполнения puppet в этом окружении.
\item[Rakefile] Rake --- это система автоматизации, похожая на классический make. Этот файл просто описывает действие spec, которое выполняет все тесты в этом модуле. Если вам требуется выполнять какие-то дополнительные задачи до или после работы тестов, то их можно добавить в этот файл.
\end{description}

Наш модуль описывает только один ресурс --- file с определёнными параметрами. Спецификация его работы выглядит так:

\begin{verbatim}
require 'spec_helper'

describe 'motd' do
  it do
    should contain_file('/etc/motd').with({
      'ensure' => 'present',
      'owner'  => 'root',
      'group'  => 'root',
      'mode'   => '0644',
    })
  end

  it do
    should contain_file('/etc/motd').with_content('Hello!')
  end

end
\end{verbatim}

Сначала мы проверяем, что каталог содержит ресурс file с указанными параметрами, затем проверяем, что содержимое этого файла соответствует задаче. Запустим тест и посмотрим на результат.

\begin{verbatim}
> rspec -f doc --color spec/classes/init_spec.rb 

motd
  should contain File[/etc/motd] with ensure => "present", owner => "root",
                                      group => "root" and mode => "0644"
  should contain File[/etc/motd] with content => "Hello!"

Finished in 0.0827 seconds
2 examples, 0 failures
\end{verbatim}

Оба теста завершено успешно.

Тесты также можно запустить используя rake благодаря задаче, которая описана в Rakefile.

\begin{verbatim}
rake spec
\end{verbatim}

Чтобы задать с какими параметрами rspec должен запускаться можно создать файл \textbf{.rspec} в корне этого модуля с таким содержанием:

\begin{verbatim}
--colour
--format documentation
\end{verbatim}

Или можно передать дополнительные параметры, переопределяющие установленные, если нужно один раз выполнить тесты с другими параметрами:

\begin{verbatim}
rake spec SPEC_OPTS="--format html"
\end{verbatim}

Теперь предположим, что при создании этого модуля была допущена ошибка и вместо строки 'Hello!' передаётся строка 'Helo!'. Посмотрим на результат тестов.

\begin{verbatim}
> rake spec
/usr/bin/ruby1.9.1 -S rspec spec/classes/init_spec.rb

motd
  should contain File[/etc/motd] with ensure => "present", owner => "root",
                                      group => "root" and mode => "0644"
  should contain File[/etc/motd] with content => "Hello!" (FAILED - 1)

Failures:

  1) motd 
     Failure/Error: should contain_file('/etc/motd').with_content('Hello!')
       expected that the catalogue would contain File[/etc/motd]
       with content set to `"Hello!"` but it is set to `"Helo!"` in the catalogue
     # ./spec/classes/init_spec.rb:15:in `block (2 levels) in <top (required)>'

Finished in 0.08056 seconds
2 examples, 1 failure

Failed examples:

rspec ./spec/classes/init_spec.rb:14 # motd 
rake aborted!
\end{verbatim}

Один из тестов провален, потому что содержимое файла не соответствует ожидаемому, но остальные параметры файла правильные и первый тест успешен. Таким образом такая мелкая ошибка, на поиск которой зачастую может быть потрачено много часов и нервов, была обнаружена еще до начала настоящего тестирование манифеста.
