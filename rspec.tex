\chapter{Unit тесты Rspec}

\section{Основы работы с Rspec}

\subsection{Технологии тестирование кода}

Rspec --- фреймворк \emph{Unit тестов} для программ, написанных на Ruby. Unit тесты позволяют программистам разделить программу на составные части и автоматически проверить корректность каждой из них. Для такой проверки требуется написание специальных тестов для каждой достаточно нетривиальной части программы. Тестирование позволяет легко находить ошибки и регрессии, которые могут возникнуть в процессе разработки.

Система Unit тестов уменьшает сложность поддержки программного кода и упрощает внесение изменений, помогая программистам обнаружить возможные побочные эффекты каждого изменения. Обычно Unit тесты создаются в процессе работы над программой, или даже после её написания. Чем большее число объектов и методов программы тестируется с разными возможными вариантами входных данных, тем выше \emph{покрытие тестами} кода.

Разработка через тестирование --- такая практика программирования, при которой перед написанием самой программы создаётся набор тестов, описывающих её работу, а разработка самой программы начинается уже после завершения работы над тестами. Эта методика позволяет использовать тесты не только для автоматического поиска проблем и ошибок, но и как \emph{спецификацию} программы, или даже \emph{исполняемую документацию}. При этом можно говорить скорее о покрытии спецификации кодом, чем о покрытии кода тестами.

Такой процесс разработки часто используется в Гибкой (Agile) методике разработки и он построен из большого количества коротких итераций, каждая из которых содержит следующие этапы:

\begin{description}
\item[Написание спецификации.]
Сначала создаётся спецификация, которая описывает все функции, которые планируется реализовать на этой итерации. При этом указываются условия, входные данные и результат, который должны возвращать эти функции.
\item[Первый запуск тестов.]
Запускается тест по созданной спецификации. Этот тест должен провалиться потому что кода, реализующего описанные возможности ещё не существует. Если тест не провалился, то это может означать что спецификация написана неправильно.
\item[Разработка функционала.]
Теперь можно приступить к написанию кода. При этом нужно стараться руководствоваться спецификации и писать минимум кода, который необходим чтобы тесты завершились успешно.
\item[Повторный запуск тестов.]
Тесты запускаются снова и проверяется правильность написания кода. Если код корректен тесты должны пройти.
\item[Рефакторинг.]
Когда тесты начнут проходить можно начинать делать рефакторинг кода чтобы улучшить его качество. Можно продолжать использовать тесты чтобы убедиться в осутствии ошибок и регрессий.
\end{description}

Этот процесс сильно отличается от классической Каскадной (Waterfall) модели, при которой сначала планируются все возможности, разрабатывается архитектура, реализуются все компоненты, и только после этого пишутся тесты для проверки созданного кода. Это делает внесение изменений в структуру проекта довольно сложным, и работающая версия получается только на последних этапах работы. Написание тестов после кода часто способствует тому, что на тесты уделяется мало внимания.

Тестирование поведения --- расширение концепции разработки через тестирование, при котором фокус делается не на описание структуры программы и соответствие работы каждого её компонента спецификации, а на поведение всей программы целиком и ее реакции на различные ситуации и исходные данные. Это позволяет говорить о всей программе как о некотором чёрном ящике, который ведёт себя определённым образом при передаче ему входных данных. Такой подход даёт возможность участвовать в процессе разработки спецификации людям, которые далеки от программирования, но хорошо знакомы с бизнес-процессами, которые должна реализовывать разрабатываемая программа.

Unit тесты Rspec могут использоваться и в классической методике разработки, и в разработке через тестирование. Оба метода широко распространены, и вы можете выбрать тот, который больше подходит для вас. Если разработка модулей ведётся с чистого листа, то может быть удобно сначала написать спецификацию, которая описывает что модуль может делать, а потом начинать разработку руководствуясь этой спецификацией. Если вам нужно заниматься поддержкой уже существующих модулей, то будет удобнее создавать набор тестов, который проверяет уже существующий код.

Язык, используемый при написании тестов, довольно близок к самому языку Ruby и не подходит для того, чтобы в полной мере реализовать рабочий процесс, основанный на методике описания поведения в спецификации. Для этого больше подойдет система, позволяющая писать спецификацию на понятном не-программистам языке --- \emph{Cucumber}. Этот проект часто используется при описании бизнес-логики Ruby приложений, но совсем не подходит для работы с Puppet.

\subsection{Создание спецификации для Ruby приложения}

Попробуем создать простое Ruby приложение по методике разработки через тестирование, написав сначала его спецификацию. Для начала установим сам Rspec. Это можно сделать при помощи gem.

\begin{verbatim}
gem install rspec
\end{verbatim}

Или при помощи пакетного менеджера вашего дистрибутива.

\begin{verbatim}
apt-get install ruby-rspec
yum install rubygem-rspec
\end{verbatim}

Разработаем простую программу для сложения или вычитания чисел. Программа должна складывать или вычитать все переданные ей числа и выводить результат. Описание поведения пишется при помощи специального предметно-ориентированного языка. При описании используется три ключевых понятия:

\begin{description}
\item[Дано]
Это понятие задаёт условия, при которых производится тестирование. Это может быть как создание экземпляров классов, так и более сложные приготовления к началу теста.
\item[Если] 
Здесь описывается некоторое событие или входные данные, которые передаются этой программе.
\item[Тогда]
Описание результата работы программы. Каким он должен быть для того, чтобы тест можно было считать успешным.
\end{description}

Для начала использования rspec нужно создать необходимую структура каталогов. Это можно сделать при помощи \emph{rspec -{}-init}. Команда создаст каталог \file{spec}, в котором должны находится все спецификации, и файл \file{rspec\_helper.rb} предназначенный для настройки \emph{rspec}.

\begin{verbatim}
rspec --init
\end{verbatim}

Теперь опишем группу тестов при помощи слова \emph{describe}. Весь связанный с ней блок тестов будет входить в эту группу. Группы могут быть вложенными друг в друга и вместо слова \emph{describe} может быть использовано слово \emph{context}. Тесты описываются при помощи ключевого слова \emph{it}.

\lstinputlisting[title={Spec для SumNumbers}]{code/SumNumbers/spec/SumNumbers_spec.rb}

Теперь напишем саму программу так, чтобы все тесты могли завершиться успешно. Создадим Ruby класс с тремя методами: конструктором, устанавливающим начальное значение, методом, прибавляющем к этому значению число, и методом, возвращающим хранимое значение.

\lstinputlisting[title={Программа SumNumbers}]{code/SumNumbers/SumNumbers.rb}

Теперь запустим тесты и посмотрим на результат. Тест можно запустить при помощи команды \emph{rspec}. Укажем формат documentation, чтобы включить вывод всех выполненных тестов.

\begin{verbatim}
rspec -f doc SumNumbers_spec.rb
\end{verbatim}

\VerbatimInput{code/SumNumbers/result_good.log}

Теперь рассмотрим ситуацию, когда в программе есть ошибка, и тесты завершаются неудачно. Предположим, что был неправильно реализован метод вычитания, и он прибавляет числа к сумме.

\lstinputlisting[title={Программа SumNumbers с ошибкой}]{code/SumNumbers/BadSumNumbers.rb}

Теперь снова запустим тесты и убедимся в том, что они не проходят.

\VerbatimInput{code/SumNumbers/result_bad.log}

Здесь мы видим, что один из тестов был провален с указанием того, какое значение ожидалось, и какое было получено.

\subsection{Совпадения и ожидания}

При проверке соответствия результатов выполнения программы правильному значению используются такие понятия как Expectations (Ожидания) и Matchers (Совпадения). Expectations устанавливаются автоматически при установке Rspec и добавляют два метода каждому Ruby объекту, которые используются для сравнения полученного значения с тем, которое должно быть, или не должно быть.

\begin{verbatim}
foo.should eq(bar)
foo.should_not eq(bar)
\end{verbatim}

Можно использовать альтернативный синтаксис:

\begin{verbatim}
expect(foo).to eq(bar)
expect(foo).not_to eq(bar) 
\end{verbatim}

Аргументом для этих объектов должно быть Совпадение. Эти объекты определяют разные условия, которые могут ожидаться или не ожидаться при проверке. Среди встроенных совпадений можно найти равенство, неравенство, нахождение в массиве, принадлежность классу и многие другие.

\begin{description}
\item[Сайт Rspec] \url{http://rspec.info}
\item[Документация] \url{https://www.relishapp.com/rspec}
\item[GitHub] \url{https://github.com/rspec/rspec}
\end{description}

%---------------------------------------------------------------

\section{Использование Rspec для проверки модулей Puppet}

\subsection{Подготовка к использованию тестов}

Тестирование поведения модулей и манифестов puppet не предусматривает их запуск на реальной или виртуальной системе, а описывает, какие ресурсы и с какими параметрами должны быть собраны в каталог, который затем был бы исполнен на управляемой системе. Таким образом проверяется логика, реализуемая модулем и манифестом посредством проверки соответствия результатов их работы эталонным результатам в указанных условиях с определёнными параметрами.

Например можно убедиться, что на Debian системе будет установлен пакет apache и создан файл \file{mysite.ru.conf} c описанием этого сайта в каталоге \file{sites-aviable}  и создана символическая ссылка на этот файл в \file{sites-enabled}. А при запуске на Red Hat системе вместо этого будет установлен пакет httpd и создан файл \file{mysite.ru.conf} в каталоге \file{conf.d}.

Такой тест совершенно не гарантирует, что все эти действия действительно будут выполнены правильно, он только проверяет правильность постановки задачи для исполнения на управляемой системе. Процесс может завершиться неудачно по множеству причин, которые не зависят от правильности написания этого манифеста. Поэтому использование Rspec совместно с Puppet может быть полезно только на очень крупных проектах. При увеличении количества управляемых ресурсов, появлении сложных условий и логики, поддержке многих конфигураций и версий операционных систем и, особенно, при дальнейшей доработке существующих манифестов отладка и тестирование может стать очень сложной. Поэтому Unit тесты, хотя и не заменят проверки на тестовых системах, помогут обнаружить многие логические ошибки, регрессии и несоответствия спецификации еще до начала полного тестирования. Кроме этого хорошо написанные тесты также выполняют функцию "исполняемой документации", описывая поведение каждого манифеста на языке, который легко понятен не только компьютеру, но и человеку.

Чтобы использовать Rspec для тестирования модулей Puppet нужно сначала установить пакет rspec-puppet, который можно найти здесь \url{http://rspec-puppet.com}. Кроме него потребуется установить сам puppet и дополнительный пакет puppetlabs\_spec\_helper.

\begin{verbatim}
gem install rspec-puppet
gem install puppetlabs_spec_helper
gem install puppet
\end{verbatim}

\subsection{Тестирование простого класса}

Рассмотрим использование Rspec на примере тестирование простого модуля puppet. Предположим, что у нас есть модуль для управления файлом \file{/etc/motd}, состоящий из одного класса.

\lstinputlisting[title={Класс motd}]{code/motd/manifests/init.pp}

Оформим этот класс как модуль, создав соответствующую структуру каталогов и положив этот класс в файл \file{init.pp} в каталоге manifests и воспользуемся скриптом \emph{rspec-puppet-init} перейдя в каталог этого модуля чтобы создать необходимую для работы Unit тестов структуру файлов и каталогов. При запуске будут созданы файлы и каталоги, которые используются для запуска тестов Rspec.

\begin{verbatim}
 + spec/
 + spec/classes/
 + spec/defines/
 + spec/functions/
 + spec/hosts/
 + spec/fixtures/
 + spec/fixtures/manifests/
 + spec/fixtures/modules/
 + spec/fixtures/modules/motd/
 + spec/fixtures/manifests/site.pp
 + spec/fixtures/modules/motd/manifests
 + spec/spec_helper.rb
 + Rakefile
\end{verbatim}

В результате должна получится такая структура каталогов и файлов. Рассмотрим для чего используются новые файлы и каталоги.

\VerbatimInput{code/motd/log/tree.log}

\begin{description}
\item[classes] В этом каталоге нужно размещать файлы, описывающие поведение классов и параметрических классов.
\item[defines] В этом каталоге нужно размещать описание поведения определений.
\item[hosts] Здесь размещаются описания работы модуля на разных системах.
\item[functions] Описания работы специальных функций, если модуль их содержит.
\item[fixtures] Здесь создаются символические ссылки, имитирующие структуру каталога с модулями puppet чтобы создать подходящие для работы модуля окружение. Файл \file{spec\_helper.rb} используется для выполнения puppet в этом окружении.
\item[Rakefile] Rake --- это система автоматизации, похожая на классический make. Этот файл просто описывает действие spec, которое выполняет все тесты в этом модуле. Если вам требуется выполнять какие-то дополнительные задачи до или после работы тестов, то их можно добавить в этот файл.
\end{description}

Наш модуль описывает только один ресурс --- file с определёнными параметрами. Файл со спецификацией всегда должен заканчиваться на \file{\_spec.rb} и, поскольку спецификация описывает класс, создадим файл в каталоге \file{spec/classes}.

\lstinputlisting[title={Спецификация класса motd}]{code/motd/spec/classes/motd_spec.rb}

Сначала мы проверяем, что каталог содержит ресурс file с указанными параметрами, затем проверяем, что содержимое этого файла соответствует задаче. Запустим тест и посмотрим на результат.

\lstinputlisting[language=sh]{code/motd/log/pass.log}

Оба теста завершено успешно. тесты также можно запустить используя rake благодаря задаче, которая описана в \file{Rakefile}.

\begin{verbatim}
rake spec
\end{verbatim}

Чтобы задать с какими параметрами rspec должен запускаться можно создать файл \file{.rspec} в корне этого модуля с таким содержанием:

\VerbatimInput{code/motd/.rspec}

Или можно передать дополнительные параметры, переопределяющие установленные, если нужно один раз выполнить тесты с другими параметрами:

\begin{verbatim}
rake spec SPEC_OPTS="--format html"
\end{verbatim}

Теперь предположим, что при создании этого модуля была допущена ошибка и вместо строки 'Hello!' передаётся строка 'Helo!'. Посмотрим на результат тестов.

\lstinputlisting[language=sh]{code/motd/log/fail.log}

Один из тестов провален, потому что содержимое файла не соответствует ожидаемому, но остальные параметры файла правильные и первый тест успешен. Таким образом такая мелкая ошибка, на поиск которой зачастую может быть потрачено много часов и нервов, была обнаружена еще до начала настоящего тестирование манифеста.

\subsection{Создание набора тестов для более сложного класса}

Теперь разработаем более сложный модуль, содержащий все типы спецификаций. Предположим, что нам нужен модуль, который бы устанавливал apache на Debian и CentOS системах и мог создавать конфигурационный файлы, описывающие сайты. Для простоты не будем рассматривать формат этих конфигурационных файлов.

Спецификация этого класса должна описывать все возможные варианты установки и удаления пакета и выбора названия пакета в соответствии с семейством операционных систем. Разобьём её на два контекста --- для операционных систем семейства Debian и RedHat. Внутри каждого контекста можно разместить тест установки выбранного пакета вместе с вложенным контекстом для его удаления.

\lstinputlisting[title={Спецификация класса для установки или удаления apache}]{code/apache/spec/classes/apache_spec.rb}

Теперь можно переходить к созданию самого модуля, который бы удовлетворял это спецификации.

\lstinputlisting[title={Класс для установки или удаления apache}]{code/apache/manifests/init.pp}

Кроме этого класса нам буден нужно определение, которое может создавать конфигурационные файлы для сайтов в правильном месте для каждой поддерживаемой операционной системы.
Определение должно учитывать разницу в пути к каталогу с настройками сайтов и то, что в Debian и Ubuntu потребуется кроме самого файла создать дополнительную символическую ссылку, указывающую на этот конфигурационный файл. Здесь нам тоже потребуется два контекста для разных операционных систем.

\lstinputlisting[title={Спецификация для определения, создающего настройки сайтов}]{code/apache/spec/defines/vhost_spec.rb}

После спецификации напишем код самого определения:

\lstinputlisting[title={Определение для создания конфигурационного файла сайта}]{code/apache/manifests/site.pp}

Теперь запустим эти тесты и проверим, что наш модуль их проходит.

\lstinputlisting[language=sh]{code/apache/log/rspec.log}

Rake автоматически прошёл по всем файлам спецификации в этом модуле, включая тесты функций и исключений, которые будут рассмотрены в следующем разделе.

%-----------------------------------------------------------------

\section{Расширения Rspec для работы с Puppet}

Рассмотрим какие дополнительные возможности для работы с Puppet модулями и манифестами предоставляет rspec-puppet. Официальную документацию этого проекта можно найти здесь \url{http://rspec-puppet.com/}.

\subsection{Параметры и факты}

При тестировании модулей и манифестов Puppet первым делом нужно задать входные данные, которые определяют процесс сборки каталога. Этими данными обычно являются факты, которые были переданы управляемой системой, и параметры для параметрических классов и определений. Параметры и факты указываются для каждого теста. Тесты можно объединять в контексты, объединяющие один набор входных данных, которые могут быть вложены друг в друга.

\begin{description}

\item[params]
Задаёт набор параметров, которые передаются параметрическому классу или определению при их тестировании.
\begin{lstlisting}
let(:params) { {
  :status  => true,
  :log     => '/var/log/my.log',
} }
\end{lstlisting}
Блок кода должен возвращать хэш с набором параметров.

\item[title]
Задаёт имя определения.
\begin{lstlisting}
let(:title) { 'test1' }
\end{lstlisting}

\item[node]
Задаёт полное имя сервера.
\begin{lstlisting}
let(:node) { 'testserver.example.com' }
\end{lstlisting}

\item[facts]
Задаёт набор фактов, заменяющий те, которые были бы переданы управляемой системой при подключении.
\begin{lstlisting}
let(:facts) { {
  :operatingsystem => 'Ubuntu',
  :osfamily        => 'Debian',
} }
\end{lstlisting}

\end{description}

\subsection{Совпадения}

Puppet-rspec добавляет несколько дополнительных проверок, которые можно использовать для определения соответствия результата сборки каталога тому, что ожидается в спецификации.

\begin{description}
\item[include\_class]
Проверка, произошло ли включение указанного класса. Например если тестируемый класс или сервер должен включать, или не включать, другой класс при определённых условиях.

\begin{lstlisting}
it { should include_class('ssh::config') }
\end{lstlisting}

\item[contain\_\textless{}resource\textgreater{}]
Проверка, произошло ли включение определённого ресурса. Вместо \textless{}resource\textgreater{} должно быть подставлено название ресурса.

\begin{lstlisting}
it { should contain_file('/etc/motd') }
it { should contain_package('nginx') }
it { should contain_service('ntpd') }
\end{lstlisting}

\item[with\_* и without\_*]
Эти совпадения можно использовать для того, чтобы проверить наличие, или отсутствие, параметров и их значений. Обычно их добавляют в конец строки условия проверки.

\begin{lstlisting}
it { should contain_service('sshd').with_ensure('running') }
it { should contain_file('/etc/motd').with_content('Hello!') }
it { should contain_file('/etc/ssh/ssh_config').with_content(/StrictHostKeyChecking\s+no/) }
it { should contain_user('user1').without_managehome(true) }
\end{lstlisting}

Проверка совпадения происходит с учётом минимального вхождения, то есть достаточно чтобы присутствовали описанные параметры, при этом может быть много других, которые не были описаны. Значения можно проверять на соответствие регулярному выражению.

\item[only\_with\_*]
Это совпадение похоже на предыдущее, но проверяет наличие у ресурса строго определённого набора параметров, и никаких дополнительных.

\begin{lstlisting}
it do
  should contain_service('nginx').only_with(
    'ensure'     => 'running',
    'enable'     => true,
    'hasrestart' => true,
    'hasstatus'  => true,
  )
end

it do
  should contain_user('user1').only_with(
    'ensure' => 'present',
    'uid'    => '501',
  )
end
\end{lstlisting}

\item[have\_resource\_count]
Совпадение проверяет точное количество ресурсов описанных в манифесте.

\begin{lstlisting}
it { should have_resource_count(5) }
\end{lstlisting}

\item[have\_class\_count]
Совпадение проверяет точное количество классов, которы были включены при сборке каталога.

\begin{lstlisting}
it { should have_class_count(3) }
\end{lstlisting}

\item[have\_\textless{}resource\textgreater{}\_resource\_count]
Определяет количество в манифесте ресурсов или определений с указанным названием. Если название определения содержит '::', то эти символы заменяются на '\_\_' (два символа подчёркивания).

\begin{lstlisting}
it { should have_file_resource_count(10) }
it { should have_nginx__site_resource_count(5) }
\end{lstlisting}

\item[run]
Используется при тестировании функций. Позволяет передать входные данные и проверить возвращаемое значение.

\begin{lstlisting}
describe 'sum'
  it do
    should run.with_params(2, 2).and_return(4)
  end
end
\end{lstlisting}

\end{description}

\subsection{Тестирование исключений}

Иногда может возникать ситуация, когда нужно проверить появится ли определённая ошибка в заданных условиях. Проверить появление ошибки можно вот таким способом.

\lstinputlisting[title={Проверка появления исключения и его сообщения}]{code/apache/spec/classes/apache_freebsd_spec.rb}

При этом проверяется не только факт появления исключения, но и текст сообщения.

\subsection{Тестирование функций}

Если вам нужно протестировать встроенную функцию Puppet, или одну из дополнительных созданных вами функций, то это тоже можно сделать при помощи Rspec. Рассмотрим примеры таких тестов.

\lstinputlisting[title={Тестирование функции md5}]{code/apache/spec/functions/md5_spec.rb}
\lstinputlisting[title={Тестирование функции generate, вызывающую консольную команду}]{code/apache/spec/functions/generate_spec.rb}
